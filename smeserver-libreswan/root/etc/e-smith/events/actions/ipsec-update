#!/usr/bin/perl -w
#----------------------------------------------------------------------
# Ipsec actions
# Copyright (C) 2015 John Crisp
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License or more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
#----------------------------------------------------------------------

# Note that we do not need to use the init ipsec script - we can start and
# stop directly using /usr/sbin/ipsec which will call the init script

use strict;
use warnings;
use esmith::ConfigDB;

my $configDB = esmith::ConfigDB->open_ro or die("can't open Config DB");
my $ipsecDB = esmith::ConfigDB->open_ro('ipsec_connections')
  or die("cant connect to ipsec database");

my $dbKey = 'ipsec';

# If the service is set disabled then make sure it is stopped
# Note that ipsec is not a service so we cannot use the normal service commands

if ( $configDB->get_prop( $dbKey, 'status' ) eq 'disabled' )
{
	print "ipsec disabled - Stopping ipsec\n";
	my $myStopConnection = qx(/etc/rc.d/init.d/ipsec stop);
	die("Unable to launch ipsec stop: $!\n")
	  if not defined $myStopConnection;
	die("ipsec stop failed (error code $?)\n") if $?;

	exit 0;
}

# If the service is set to enabled AND running (then check the connections)
if ( $configDB->get_prop( $dbKey, 'status' ) eq 'enabled' )
{

	my $status = (`ps ax | grep -v grep | grep pluto`);

	#If the service is running
	if ( $status =~ m/pluto/ )
	{
		# Lets do some shit
		print "ipsec is running!\n";
		my @connections = $ipsecDB->keys;

		foreach my $ipsecprop (@connections)
		{
			#Check the individual connection status
			my $ipsecstatus =
			  $ipsecDB->get_prop( "$ipsecprop", 'status' ) || "disabled";

			# If we are enabled
			if ( $ipsecstatus eq "enabled" )
			{
				print "ReReading Secrets\n";
				my $reread = qx(/usr/sbin/ipsec auto --rereadsecrets);

				die("Unable launch ipsec reread secrets: $!\n")
				  if not defined $reread;
				die("ipsec reread secrets failed (error code $?)\n") if $?;

				print "Restarting connection $ipsecprop\n";
				my $restart = qx(/usr/sbin/ipsec auto --replace $ipsecprop);

				die("Unable to launch ipsec replace: $!\n")
				  if not defined $restart;
				die("ipsec replace failed (error code $?)\n") if $?;
			}

			# If status is disabled then stop it
			else
			{
				print "connection $ipsecprop disabled";
				my $stopConnection = qx(/usr/sbin/ipsec --down $ipsecprop);
				die("Unable to launch ipsec stop: $!\n")
				  if not defined $stopConnection;
				die("ipsec stop failed (error code $?)\n") if $?;
			}

		}

	}

	# If it isn't running then start it up
	# Auto connections start themselves. Added connections wait
	else
	{
	  #		print "ipsec isn't running so start ipsec\n";
	  #		system("/etc/rc.d/init.d/ipsec start") == 0 or die "system failed: $?";
	  #		print "ipsec started\n";

		print "ipsec enabled - Starting ipsec\n";
		my $myStartConnection = qx(/etc/rc.d/init.d/ipsec start);
		die("Unable to launch ipsec start: $!\n")
		  if not defined $myStartConnection;
		die("ipsec start failed (error code $?)\n") if $?;

		exit 0;
	}

}

exit(0);
